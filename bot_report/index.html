<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Отчёт о проекте: Telegram-бот на Node.js</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            width: 90%;
            max-width: 960px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.5rem;
            margin-top: 2rem;
            color: #2c3e50;
        }

        h3 {
            font-size: 1.25rem;
            margin-top: 1.5rem;
            color: #34495e;
        }

        p {
            margin: 1rem 0;
        }

        ul,
        ol {
            margin: 1rem 0 1rem 2rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #f0f0f0;
        }

        pre {
            background-color: #ecf0f1;
            color: #3498db;
            padding: 1rem;
            overflow-x: auto;
            border-radius: 6px;
            margin: 1rem 0;
        }

        code {
            background-color: #f0f0f000;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, monospace;
        }

        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 2rem 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ОТЧЁТ О ПРОЕКТЕ: Разработка Telegram-бота на Node.js</h1>

        <h2>Введение</h2>
        <p>Современные мессенджеры давно перестали быть просто средством общения. Они стали полноценными платформами, на
            базе которых создаются умные ассистенты, игровые механики, системы опросов, интеграции с бизнесом и даже
            целые образовательные сервисы. Одним из самых популярных инструментов для этих целей является Telegram,
            благодаря открытому API и поддержке ботов.</p>
        <p>В рамках данного проекта мы поставили перед собой задачу — создать Telegram-бота на языке JavaScript
            (Node.js) с использованием таких инструментов, как Express, Axios и body-parser. При этом цель была не
            просто сделать «бота, который отвечает», а реализовать интерактивную, расширяемую архитектуру, способную
            запоминать состояние пользователя, работать с командами и кнопками.</p>
        <p>Проект развивался поэтапно: сначала — базовая реализация, затем — постепенное добавление функций,
            инлайн-кнопок, логики обработки состояний и взаимодействия с пользователем.</p>

        <hr>

        <h2>Технологический стек</h2>
        <table>
            <thead>
                <tr>
                    <th>Технология</th>
                    <th>Назначение</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Node.js</td>
                    <td>Среда выполнения JavaScript</td>
                </tr>
                <tr>
                    <td>Express</td>
                    <td>Веб-фреймворк для создания REST-сервера</td>
                </tr>
                <tr>
                    <td>Axios</td>
                    <td>Библиотека для HTTP-запросов</td>
                </tr>
                <tr>
                    <td>body-parser</td>
                    <td>Парсинг тела POST-запросов</td>
                </tr>
                <tr>
                    <td>Telegram Bot API</td>
                    <td>Взаимодействие с Telegram-ботом</td>
                </tr>
            </tbody>
        </table>

        <hr>

        <h2>Документация и сопровождение проекта</h2>
        <p>Разработка Telegram-бота — это не только код, но и его понятное описание, чтобы другие участники команды (или
            даже будущие мы сами) могли быстро вникнуть, поддерживать и дорабатывать систему. Поэтому параллельно с
            работой над функционалом, мы уделили особое внимание созданию документации.</p>

        <hr>

        <h2>Руководство по созданию бота для начинающих</h2>
        <ul>
            <li>Зарегистрировать бота через BotFather</li>
            <li>Получить и использовать токен</li>
            <li>Настроить Node.js и Express</li>
            <li>Написать базовый обработчик сообщений</li>
            <li>Отправлять простые ответы пользователям</li>
            <li>Обрабатывать команды и кнопки</li>
        </ul>
        <p>Это руководство было создано с расчётом на тех, кто никогда не писал ботов и даже, возможно, только начинает
            свой путь в программировании. Мы включили в него примеры кода, визуальные пояснения, разбор ошибок и советы
            по отладке. Все шаги были проверены на практике, чтобы читатель не остался наедине с "падает, не знаю
            почему".</p>
        <p><strong>Цель:</strong> сделать процесс создания первого бота лёгким, понятным и вдохновляющим.</p>

        <hr>

        <h2>Руководство по проекту и модификациям</h2>
        <ul>
            <li>Архитектура и структура проекта</li>
            <li>Зачем и как мы разделили логику на блоки (обработка сообщений, кнопок, состояний)</li>
            <li>Какие команды реализованы и почему</li>
            <li>Что делает каждая функция</li>
            <li>Идеи для расширения (бот для викторин, справочник, чат-игра и т.д.)</li>
        </ul>
        <p>Мы стремились сделать так, чтобы любой разработчик, открывший проект, мог разобраться в нём за 15 минут и
            сразу начать работу. Это особенно важно в командной разработке, при передаче проекта или при доработке через
            месяцы.</p>

        <hr>

        <h2>Подробная модификация: не просто улучшения, а переход на новый уровень</h2>
        <p>Мы также пошли дальше и добавили в проект расширенную модификацию, о которой говорилось выше. В основном
            руководстве (для новичков) мы сознательно не вдавались в детали:</p>
        <ul>
            <li>не описывали работу <code>callback_query</code></li>
            <li>не касались хранения состояния пользователя</li>
            <li>не объясняли, как делать пошаговые сценарии</li>
        </ul>
        <p>Это было сделано осознанно — чтобы не перегружать начинающего разработчика. Однако в рамках данного отчёта и
            модификации проекта мы решили:</p>
        <p>Разобрать всё детально, шаг за шагом — как создаётся логика бота, как работает инлайн-клавиатура, что такое
            <code>userStates</code>, как обрабатываются различные команды и почему это важно для UX.
        </p>
        <p>Мы не просто улучшили проект — мы перевели его на новый уровень: теперь бот умеет вести диалог, обрабатывать
            нажатия кнопок, задавать вопросы, запоминать, что делает пользователь, и действовать исходя из контекста.
        </p>

        <hr>

        <h2>Архитектура проекта</h2>
        <h3>Структура</h3>
        <p>Проект построен на простом и понятном сервере Express, который обрабатывает POST-запросы от Telegram,
            присылаемые при каждом новом сообщении или взаимодействии пользователя с ботом. Ниже показано, как устроена
            базовая архитектура:
        </p>
        <pre><code>Telegram (user) -> POST /new-message -> Обработка сообщения -> Ответ через Telegram Bot API</code></pre>

        <hr>

        <h2>Реализация</h2>
        <h3>Шаг 1: Базовый сервер</h3>
        <p>Проект начинается с создания Express-сервера и настройки базового маршрута для приёма сообщений от Telegram.
        </p>
        <pre><code>const express = require("express")
 const app = express()
 const bodyParser = require("body-parser")
 const axios = require("axios")

 const TOKEN = "ВАШ_ТОКЕН_ТУТ"
 const TELEGRAM_API = `https://api.telegram.org/bot${TOKEN}`

 app.use(bodyParser.json())
 app.use(bodyParser.urlencoded({ extended: true }))</code></pre>

        <h3>Шаг 2: Обработка входящих сообщений</h3>
        <p>Мы проверяем, содержит ли входящее сообщение необходимые данные. Если да — анализируем текст и отправляем
            соответствующий ответ.
            На первом этапе бот просто реагирует на слово "привет".
        </p>
        <pre><code>app.post("/new-message", (req, res) => {
  const { message } = req.body

  if (!message || !message.text || !message.chat) {
    return res.end()
  }

  const text = message.text.toLowerCase()

  if (text.includes("привет")) {
    axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: message.chat.id,
      text: "вечер в хату!!",
    })
    .then(() => res.end("ok"))
    .catch((err) => {
      console.error("Ошибка отправки:", err)
      res.end("Ошибка: " + err)
    })
  } else {
    res.end("ok")
  }
})</code></pre>

        <p>Бот запускается на порту 3000:
        </p>

        <pre><code>app.listen(3000, () => {
  console.log("Сервер запущен на порту 3000")
})</code></pre>

        <hr>

        <h2>Расширенные функции</h2>

        <p>После успешного запуска базовой версии мы начали поэтапное расширение:
        </p>

        <h3>Команда <code>/start</code> и справка</h3>
        <pre><code>if (message.text.toLowerCase() === "/start") {
  axios.post(`${TELEGRAM_API}/sendMessage`, {
    chat_id: message.chat.id,
    text: "Добро пожаловать! Доступные команды:\n/help - помощь\n/joke - случайный анекдот",
    parse_mode: "Markdown"
  })
  return res.end()
}</code></pre>

        <li>Цель: дать пользователю понимание, что бот умеет делать.</li>
        <li>Особенность: используется Markdown-разметка для форматирования текста.</li>

        <h3>Обработка состояния пользователя</h3>
        <p>Важным шагом стало внедрение механизма запоминания, что делает пользователь:</p>
        <pre><code>const userStates = {}

if (message.text === "/quiz") {
  userStates[message.chat.id] = "waiting_for_answer"
  axios.post(`${TELEGRAM_API}/sendMessage`, {
    chat_id: message.chat.id,
    text: "Сколько будет 2+2?"
  })
}</code></pre>

        <p>Если пользователь отвечает:</p>
        
<pre><code>if (userStates[message.chat.id] === "waiting_for_answer') {
  if (message.text === "4") {
    axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: message.chat.id,
      text: "Правильно!"
    })
  } else {
    axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: message.chat.id,
      text: "Неправильно. Попробуйте ещё раз."
    })
  }

  delete userStates[message.chat.id]
}</code></pre>

        <li>Цель: дать пользователю понимание, что бот умеет делать.</li>

        <h3>Инлайн-клавиатура и кнопки</h3>
        <pre><code>if (message.text === "/menu") {
  axios.post(`${TELEGRAM_API}/sendMessage`, {
    chat_id: message.chat.id,
    text: "Выберите действие:",
    reply_markup: {
      inline_keyboard: [
        [{ text: "Кнопка 1", callback_data: "btn1" }],
        [{ text: "Кнопка 2", callback_data: "btn2" }]
      ]
    }
  })
}

if (req.body.callback_query) {
  const data = req.body.callback_query.data
  const chatId = req.body.callback_query.message.chat.id

  if (data === "btn1") {
    axios.post(`${TELEGRAM_API}/sendMessage`, {
      chat_id: chatId,
      text: "Вы нажали кнопку 1!"
    })
  }
}</code></pre>

        <p>А обработка кнопок — через callback_query:</p>

    <pre><code>if (req.body.callback_query) {
    const { data, message: callbackMessage } = req.body.callback_query;
    const chatId = callbackMessage.chat.id;
      
    if (data === "btn1") {
        await axios.post(`${API}/sendMessage`, {
        chat_id: chatId,
        text: "Вы нажали кнопку 1!"
        });
    }
      
    return res.end();
    }</code></pre>
        <p>Инлайн-клавиши делают бота более удобным и "приложением-подобным".</p>

        <hr>

        <h2>Результат и возможности развития</h2>
        <ul>
            <li>Приём сообщений и ответ на ключевые слова</li>
            <li>Обработка команд (/start, /menu, /quiz)</li>
            <li>Работа с инлайн-кнопками</li>
            <li>Реализация логики с запоминанием состояния</li>
            <li>Асинхронные запросы и отправка ответов с помощью Axios</li>
        </ul>

        <h2>Идеи для будущего расширения</h2>
        <ol>
            <li>Интеграция с внешними API (анекдоты, погода, курсы валют)</li>
            <li>Работа с базой данных — для хранения очков пользователей или истории общения</li>
            <li>Многошаговые квизы</li>
            <li>Локализация — поддержка нескольких языков</li>
            <li>Интерфейс администратора для управления ботом</li>
        </ol>

        <hr>

        <h2>Вывод</h2>
        <p>Этот проект продемонстрировал, как из простого Telegram-бота можно постепенно вырастить функциональный,
            интерактивный и отзывчивый инструмент. Несмотря на кажущуюся простоту архитектуры,
            за ботом стоит гибкая система обработки сообщений, состояний и событий.</p>
        <p>В ходе разработки Telegram-бота на Node.js мы не только построили полноценное, расширяемое приложение,
            но и оформили весь процесс в виде доступных и понятных материалов:</p>
        <li>для начинающих — пошаговое руководство</li>
        <li>для разработчиков — техническое описание архитектуры и логики</li>
        <li>для развития проекта — глубокая модификация и идеи по расширению.</li>
        <p>Проект теперь является не просто ботом, а шаблоном, платформой,
            на основе которой можно строить любые телеграм-сервисы — от образовательных до развлекательных,
            от бизнес-инструментов до игровых приложений.</p>
        <p>Благодаря чёткому подходу к разработке, вниманию к деталям, продуманной архитектуре и качественной
            документации,
            проект может легко масштабироваться и передаваться другим участникам команды.</p>
    </div>
</body>

</html>